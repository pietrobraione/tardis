package tardis.implementation.evosuite;

import static jbse.common.Type.splitParametersDescriptors;
import static tardis.implementation.common.Util.ensureInternalClassLoader;
import static tardis.implementation.common.Util.getInternalClassLoader;

import java.io.BufferedWriter;
import java.io.IOException;
import java.lang.reflect.Array;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.ImportDeclaration;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.Name;
import com.github.javaparser.ast.expr.ObjectCreationExpr;
import com.github.javaparser.ast.expr.SimpleName;
import com.github.javaparser.ast.stmt.ExpressionStmt;
import com.github.javaparser.ast.stmt.Statement;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.visitor.ModifierVisitor;
import com.github.javaparser.ast.visitor.Visitable;

import tardis.Options;
import tardis.implementation.jbse.JBSEResult;

/**
 * Splits an EvoSuite test class with one (or more) test 
 * methods and no specified target in one (or more) test
 * classes with a specific target. 
 * 
 * @author Pietro Braione
 *
 */
final class EvosuiteSplitter {
	private final Options o;
	private final String targetClassName;
	private final String targetClassName_Unqualified;
	private final String testClassName;
	private final String testClassName_Unqualified;
	private final String scaffClassName;
	private final Path testFile;
	private final Path scaffFile;
	private final List<List<String>> visibleTargetMethods;
	private final AtomicInteger testCount;
	
	private final HashSet<MethodDeclaration> generatedMethodDeclarations = new HashSet<>();
	
	/**
	 * Constructor.
	 * 
     * @param o an {@link Options} object. It must not be {@code null}.
     * @param testFileNameNoExtension a {@link String}, the name of the source file 
     *        containing the test class (without the .java extension).
     * @param targetClassName a {@link String}, the name of the target class.
     * @param visibleTargetMethod a {@link List}{@code <}{@link List}{@code <}{@link String}{@code >>}.
     *        Every element of the list must be a method signature, i.e., a list
     *        with length 3, whose elements are the class, the list of parameters
     *        type, and the name of a target method (the classes of the target
     *        methods must all be {@code String#equals(Object) equal} to {@code targetClassName}).
     * @param testCount an {@code AtomicInteger} used to identify 
     *        the generated tests.
	 */
	EvosuiteSplitter(Options o, String testFileNameNoExtension, String targetClassName, List<List<String>> visibleTargetMethods, AtomicInteger testCount) {
		this.o = o;
		this.targetClassName = targetClassName;
		this.targetClassName_Unqualified = unqualify(this.targetClassName);
		final String[] testFileNameSplit =  testFileNameNoExtension.split("_");
		this.testClassName = this.targetClassName + "_Branch_" + testFileNameSplit[testFileNameSplit.length - 2] + "_Test";
        this.testClassName_Unqualified = unqualify(this.testClassName);
		this.scaffClassName = (this.o.getEvosuiteNoDependency() ? null : this.testClassName + "_scaffolding");
		this.testFile = this.o.getTmpTestsDirectoryPath().resolve(this.testClassName + ".java");
		this.scaffFile = (this.o.getEvosuiteNoDependency() ? null : this.o.getTmpTestsDirectoryPath().resolve(this.scaffClassName + ".java"));
		this.visibleTargetMethods = visibleTargetMethods;
		this.testCount = testCount;
	}
	
    /**
     * Splits a seed test class generated by EvoSuite, 
     * with multiple test methods, into multiple classes
     * with a single test method.
     * 
     * @return a {@link List}{@code <}{@link Pair}{@code <}{@link JBSEResult}{@code , }{@link Integer}{@code >>} for all the 
     *         created classes.
     * @throws NoTestFileException if the test file does not exist.
     * @throws NoTestFileScaffoldingException if the scaffolding file does not exist. 
     * @throws IOException if some I/O error occurs during the execution of Javaparser.
     * @throws IOFileCreationException if some I/O error occurs while creating the 
     *         test class or scaffolding class, or the folder that must contain them.
     */
    List<Pair<JBSEResult, Integer>> split() 
    throws NoTestFileException, NoTestFileScaffoldingException, IOException, IOFileCreationException {
    	//defines the names of classes/compilation units, 
    	//and checks their existence
        checkTestExistence();
        
        //parses the seed compilation unit
    	final CompilationUnit cuTestClass = StaticJavaParser.parse(this.testFile);
        
        //finds all the test method declarations 
        //in the compilation unit
        final ArrayList<MethodDeclaration> testMethodDeclarations = 
        testMethodsInCompilationUnit(cuTestClass);
        
        //generates all the split classes and the return value
    	ensureInternalClassLoader(this.o.getClassesPath()); //necessary to scavenge types
        final ArrayList<Pair<JBSEResult, Integer>> retVal = new ArrayList<>();
        for (MethodDeclaration mdTest : testMethodDeclarations) {
            //builds a map of variable declarations (variable names to
            //class names)
            final HashMap<String, Class<?>> varDecls = variableDeclarationsMap(cuTestClass, mdTest);
            
            //gets all the statements in the method
            final List<ExpressionStmt> stmts = mdTest.findAll(ExpressionStmt.class);
            Collections.reverse(stmts); //from last to first one
            
            //scans all the statements and builds a test class
            //for each target method call
            for (ExpressionStmt stmt : stmts) {
                //looks for a method/constructor call in the statement
                final Expression expr = findMethodOrConstructorCall(stmt);
                if (expr == null) {
                	continue;
                }
                
                //determines if the invoked method/constructor is a target method
                final List<String> targetMethod = 
                findVisibleTargetMethod(expr, varDecls);
                if (targetMethod == null) {
                    continue;
                }

                //defines the names of the new classes
            	final int testCount = this.testCount.getAndIncrement();
                final String testClassNameNew = (this.targetClassName + "_" + testCount + "_Test");
                final String scaffClassNameNew = (this.o.getEvosuiteNoDependency() ? null : testClassNameNew + "_scaffolding");

                //creates the declaration for the test class, continues
                //if it is redundant
                final ClassOrInterfaceDeclaration cdeclTestClassNew = 
                createDeclarationTestClass(testClassNameNew, mdTest, stmt);
                if (cdeclTestClassNew == null) {
                	continue;
                }
                
                //creates the compilation unit for the scaffolding, 
                //and possibly patches the declaration for the test class
                final CompilationUnit cuTestScaffNew;
                if (this.o.getEvosuiteNoDependency()) {
                	cuTestScaffNew = null;
                } else {
                	cuTestScaffNew = createCompilationUnitScaffoldingClass(scaffClassNameNew);
                	patchCompilationUnitTestClassSuperclass(cdeclTestClassNew, scaffClassNameNew);
                }

                //creates the compilation unit for the test class
                final CompilationUnit cuTestClassNew = 
                createCompilationUnitTestClass(cuTestClass, cdeclTestClassNew);

                //writes the compilation units to files
                writeCompilationUnits(testClassNameNew, cuTestClassNew, scaffClassNameNew, cuTestScaffNew);
                
                //creates the new item
                final JBSEResult newItem = new JBSEResult(targetMethod);
                retVal.add(new Pair<>(newItem, testCount));
            }
        }
        
        return retVal;
    }
    
    private void checkTestExistence() 
    throws NoTestFileException, NoTestFileScaffoldingException {
        if (!this.testFile.toFile().exists()) {
            throw new NoTestFileException(this.testFile);
        }
        if (this.scaffFile != null && !this.scaffFile.toFile().exists()) {
            throw new NoTestFileScaffoldingException(this.scaffFile);
        }
    }
    
    private static ArrayList<MethodDeclaration> testMethodsInCompilationUnit(CompilationUnit cuTestClass) {
        final ArrayList<MethodDeclaration> retVal = new ArrayList<>();
        cuTestClass.findAll(MethodDeclaration.class).forEach(md -> {
            if (md.isAnnotationPresent("Test")) {
                retVal.add(md);
            }
        });
        return retVal;
    }
    
    private static HashMap<String, Class<?>> variableDeclarationsMap(CompilationUnit cuTestClass, MethodDeclaration mdTest) 
    throws SecurityException {
        final HashMap<String, Class<?>> retVal = new HashMap<>();
        mdTest.findAll(VariableDeclarator.class).forEach(vd -> {
            retVal.put(vd.getNameAsString(), javaTypeToClass(cuTestClass, vd.getTypeAsString()));
        });
        return retVal;
    }
    
    private static Expression findMethodOrConstructorCall(ExpressionStmt stmt) {
    	final Expression expr;
        if (stmt.getExpression().isMethodCallExpr()) {
            expr = stmt.getExpression();
        } else if (stmt.getExpression().isObjectCreationExpr()) { //unlikely
            expr = stmt.getExpression();
        } else if (stmt.getExpression().isAssignExpr() && stmt.getExpression().asAssignExpr().getValue().isMethodCallExpr()) {
            expr = stmt.getExpression().asAssignExpr().getValue();
        } else if (stmt.getExpression().isAssignExpr() && stmt.getExpression().asAssignExpr().getValue().isObjectCreationExpr()) {
            expr = stmt.getExpression().asAssignExpr().getValue();
        } else if (stmt.getExpression().isVariableDeclarationExpr() && stmt.getExpression().asVariableDeclarationExpr().getVariable(0).getInitializer().isPresent() &&
                   stmt.getExpression().asVariableDeclarationExpr().getVariable(0).getInitializer().get().isMethodCallExpr()) {
            expr = stmt.getExpression().asVariableDeclarationExpr().getVariable(0).getInitializer().get();
        } else if (stmt.getExpression().isVariableDeclarationExpr() && stmt.getExpression().asVariableDeclarationExpr().getVariable(0).getInitializer().isPresent() &&
                   stmt.getExpression().asVariableDeclarationExpr().getVariable(0).getInitializer().get().isObjectCreationExpr()) {
            expr = stmt.getExpression().asVariableDeclarationExpr().getVariable(0).getInitializer().get();
        } else {
            expr = null; //gives up
        }
        return expr;
    }
    
    private List<String> findVisibleTargetMethod(Expression expr, HashMap<String, Class<?>> varDecls) {
    	//if the method call is a constructor, and the name of the class
    	//is not that of the target class, then it returns null
    	if (expr instanceof ObjectCreationExpr && !((ObjectCreationExpr) expr).getTypeAsString().equals(this.targetClassName_Unqualified)) {
    		return null;
    	}
    	
    	//finds the name and the list of parameters type for the method specified by expr
        final String methodName = (expr instanceof MethodCallExpr ? ((MethodCallExpr) expr).getNameAsString() : "<init>");
        final ArrayList<Class<?>> argumentTypes = new ArrayList<>();
        for (Expression e : (expr instanceof MethodCallExpr ? ((MethodCallExpr) expr).getArguments() : ((ObjectCreationExpr) expr).getArguments())) {
            argumentTypes.add(inferType(e, varDecls));
        }
        
        //looks for a visible target method with same name and parameters list 
        List<String> targetMethod = null;
        visibleTargetMethodsLoop:
        for (List<String> visibleTargetMethod : this.visibleTargetMethods) {
            if (visibleTargetMethod.get(2).equals(methodName)) {
                final String[] visibleTargetMethodArgumentTypes = splitParametersDescriptors(visibleTargetMethod.get(1));
                if (visibleTargetMethodArgumentTypes.length == argumentTypes.size()) {
                    boolean allMatch = true;
                    allMatchLoop:
                    for (int i = 0; i < visibleTargetMethodArgumentTypes.length; ++i) {
                        final Class<?> argClass = argumentTypes.get(i); 
                        final Class<?> targetMethodArgClass = classFileTypeToClass(visibleTargetMethodArgumentTypes[i]);
                        if (argClass != null && targetMethodArgClass != null && !targetMethodArgClass.isAssignableFrom(argClass)) {
                            allMatch = false;
                            break allMatchLoop;
                        }
                    }
                    if (allMatch) {
                        targetMethod = visibleTargetMethod;
                        break visibleTargetMethodsLoop;
                    }
                }
            }
        }
        return targetMethod;
    }
    
    private ClassOrInterfaceDeclaration createDeclarationTestClass(String testClassNameNew, MethodDeclaration mdTest, ExpressionStmt stmt) {
        //creates a new test class declaration
        final ClassOrInterfaceDeclaration cdeclTestClass = (ClassOrInterfaceDeclaration) mdTest.getParentNode().get();
        final ClassOrInterfaceDeclaration retVal = cdeclTestClass.clone();
        
        //detects the test method to preserve
        final MethodDeclaration mdTestNew = 
        retVal.getMethodsBySignature(mdTest.getNameAsString(), mdTest.getParameters().stream().map(Parameter::getType).map(Type::toString).toArray(String[]::new)).get(0);
        
        //removes all the other test methods
        final ArrayList<MethodDeclaration> toExpunge = new ArrayList<>();
        retVal.findAll(MethodDeclaration.class).forEach(md -> {
            if (md.isAnnotationPresent("Test") && !md.equals(mdTestNew)) {
                toExpunge.add(md);
            }
        });
        for (MethodDeclaration md : toExpunge) {
            retVal.remove(md);
        }
        
        //changes the name to the only test method
        mdTestNew.setName("test0");
        
        //removes all the statements after stmt
        final List<Statement> stmts = mdTestNew.findAll(Statement.class);
        Collections.reverse(stmts); //from last to first one
        for (Statement curStmt : stmts) {
        	if (curStmt.equals(stmt)) {
        		break;
        	}
        	mdTestNew.getBody().get().remove(curStmt);
        }
        
        //checks if the method declaration is redundant, and in this
        //case returns null
        if (this.generatedMethodDeclarations.contains(mdTestNew)) {
        	return null;
        }
        
        //adds the method declaration to the set of the generated
        //method declarations
        this.generatedMethodDeclarations.add(mdTestNew);
        
        //changes the name to the test class
        final String testClassNameNew_Unqualified = unqualify(testClassNameNew);
        retVal.setName(testClassNameNew_Unqualified);
        return retVal;
    }
    
    private CompilationUnit createCompilationUnitTestClass(CompilationUnit cuTestClass, ClassOrInterfaceDeclaration cdeclTestClassNew) {
        final CompilationUnit retVal = cuTestClass.clone();
        final ClassOrInterfaceDeclaration cdeclTestClass = retVal.findFirst(ClassOrInterfaceDeclaration.class, cid -> cid.getName().asString().equals(this.testClassName_Unqualified)).get();
        retVal.replace(cdeclTestClass, cdeclTestClassNew);
        return retVal;
    }
    
    private CompilationUnit createCompilationUnitScaffoldingClass(String scaffClassNameNew) throws IOException {
    	final String scaffClassName_Unqualified = unqualify(this.scaffClassName);
    	final String scaffClassNameNew_Unqualified = unqualify(scaffClassNameNew);
    	
    	//creates the compilation unit for the new scaffolding class
    	final CompilationUnit cuTestScaffNew = StaticJavaParser.parse(this.scaffFile);
    	final ClassOrInterfaceDeclaration scaffClassDeclarationNew = cuTestScaffNew.findFirst(ClassOrInterfaceDeclaration.class, cid ->  cid.getName().asString().equals(scaffClassName_Unqualified)).get();
    	scaffClassDeclarationNew.setName(scaffClassNameNew_Unqualified);

    	//fixes the initializeClasses method
    	final RenamerVisitor v = new RenamerVisitor(scaffClassName_Unqualified, scaffClassNameNew_Unqualified);
    	cuTestScaffNew.accept(v, null);
    	    	
    	return cuTestScaffNew;
    }
    
    private void patchCompilationUnitTestClassSuperclass(ClassOrInterfaceDeclaration cdeclTestClassNew, String scaffClassNameNew) {
    	final String scaffClassName_Unqualified = unqualify(this.scaffClassName);
    	final String scaffClassNameNew_Unqualified = unqualify(scaffClassNameNew);
    	
    	//patches the "extends" declaration of the test class
    	//declaration to point to the new scaffolding class declaration
    	final NodeList<ClassOrInterfaceType> testClassExtensions = cdeclTestClassNew.getExtendedTypes();
    	for (Iterator<ClassOrInterfaceType> it = testClassExtensions.iterator(); it.hasNext(); ) {
    		final ClassOrInterfaceType testClassExtension = it.next();
    		if (testClassExtension.getName().asString().equals(scaffClassName_Unqualified)) {
    			it.remove();
    			break;
    		}
    	}
    	cdeclTestClassNew.addExtendedType(scaffClassNameNew_Unqualified);
    }
    
    private void writeCompilationUnits(String testClassNameNew, CompilationUnit cuTestClassNew, String scaffClassNameNew, CompilationUnit cuTestScaffNew) 
    throws IOFileCreationException {
        final Path testFileNew = this.o.getTmpTestsDirectoryPath().resolve(testClassNameNew + ".java");
        try {
            Files.createDirectories(testFileNew.getParent());
        } catch (IOException e) {
            throw new IOFileCreationException(e, testFileNew.getParent());
        }
        try (final BufferedWriter w = Files.newBufferedWriter(testFileNew)) {
            w.write(cuTestClassNew.toString());
        } catch (IOException e) {
            throw new IOFileCreationException(e, testFileNew);
        }
        final Path scaffFileNew;
        if (this.o.getEvosuiteNoDependency()) {
            scaffFileNew = null; //nothing else to write
        } else {
            scaffFileNew = this.o.getTmpTestsDirectoryPath().resolve(scaffClassNameNew + ".java");
            try (final BufferedWriter w = Files.newBufferedWriter(scaffFileNew)) {
                w.write(cuTestScaffNew.toString());
            } catch (IOException e) {
                throw new IOFileCreationException(e, testFileNew);
            }
        }
    }
    
    private static final class RenamerVisitor extends ModifierVisitor<Void> {
        private final String from, to;
        
        public RenamerVisitor(String from, String to) {
            this.from = from;
            this.to = to;
        }
        
        @Override
        public Visitable visit(SimpleName n, Void arg) {
            if (n.asString().equals(this.from)) {
                n.setIdentifier(this.to);
            }
            return super.visit(n, arg);
        }
        
        @Override
        public Visitable visit(Name n, Void arg) {
            if (n.asString().equals(this.from)) {
                n.setIdentifier(this.to);
            }
            return super.visit(n, arg);
        }
    }
    
    private static Class<?> javaTypeToClass(CompilationUnit cu, String type) {
        if ("boolean".equals(type)) {
            return boolean.class;
        } else if ("byte".equals(type)) {
            return byte.class;
        } else if ("char".equals(type)) {
            return char.class;
        } else if ("double".equals(type)) {
            return double.class;
        } else if ("float".equals(type)) {
            return float.class;
        } else if ("int".equals(type)) {
            return int.class;
        } else if ("long".equals(type)) {
            return long.class;
        } else if ("short".equals(type)) {
            return short.class;
        } else if (type.endsWith("[]")) {
            final Class<?> memberType = javaTypeToClass(cu, type.substring(0, type.length() - 2));
            if (memberType == null) {
                return null;
            }
            return Array.newInstance(memberType, 0).getClass();
        } else { //class name
            final ClassLoader ic = getInternalClassLoader();
            final String typeNoGenerics = eraseGenericParameters(type);
            final ArrayList<String> possiblePackageQualifiers = possiblePackageQualifiers(cu, typeNoGenerics);
            for (String possiblePackageQualifier : possiblePackageQualifiers) {
                String typeNameLoop = typeNoGenerics;
                do {
                    Class<?> retVal = null;
                    try {
                        retVal = Class.forName(possiblePackageQualifier + typeNameLoop);
                    } catch (ClassNotFoundException e) {
                        try {
                            retVal = ic.loadClass(possiblePackageQualifier + typeNameLoop);
                        } catch (ClassNotFoundException e1) {
                            retVal = null;
                        }
                    }
                    if (retVal != null) {
                        return retVal;
                    }
                    //tries to replace the last dot with a dollar and reload
                    final int lastIndexOfDot = typeNameLoop.lastIndexOf('.');
                    if (lastIndexOfDot == -1) {
                        //nothing more to try with this package qualifier
                        break;
                    }
                    final StringBuilder newTypeNameLoop = new StringBuilder(typeNameLoop);
                    newTypeNameLoop.setCharAt(lastIndexOfDot, '$');
                    typeNameLoop = newTypeNameLoop.toString();
                } while (true);
            }
            return null; //nothing found
        }
    }
    
    private static String eraseGenericParameters(String type) {
        final StringBuilder retVal = new StringBuilder();
        int level = 0;
        for (int i = 0; i < type.length(); ++i) {
            final char current = type.charAt(i);
            if (current == '<') {
                ++level;
            } else if (current == '>') {
                --level;
            } else if (level == 0) {
                retVal.append(current);
            }
        }
        return retVal.toString();
    }
    
    private static ArrayList<String> possiblePackageQualifiers(CompilationUnit cu, String type) {
        final ArrayList<String> retVal = new ArrayList<>();
        retVal.add(""); //always tries with no package qualifier
        retVal.add("java.lang."); //always tries with java.lang (for standard classes that are not imported)
        cu.findAll(ImportDeclaration.class).forEach(id -> {
            final String idString = id.getNameAsString();
            if (id.isAsterisk()) {
                retVal.add(idString + ".");
            } else {
                //if type is A.B.C tries first A, then A.B, then A.B.C
                for (int i = 0; i <= type.length(); ++i) {
                    if (i == type.length() || type.charAt(i) == '.') {
                        final String typePrefix = type.substring(0, i);
                        if (idString.endsWith("." + typePrefix)) {
                            retVal.add(idString.substring(0, idString.length() - typePrefix.length()));
                        }
                    }
                }
            } //else, do not add it
        });
        return retVal;
    }
    
    private static Class<?> inferType(Expression e, HashMap<String, Class<?>> varDecls) {
        if (e.isBooleanLiteralExpr()) {
            return boolean.class;
        } else if (e.isCharLiteralExpr()) {
            return char.class;
        } else if (e.isDoubleLiteralExpr()) {
            return double.class;
        } else if (e.isIntegerLiteralExpr()) {
            return int.class;
        } else if (e.isLongLiteralExpr()) {
            return long.class;
        } else if (e.isArrayAccessExpr()) {
            final Class<?> memberType = inferType(e.asArrayAccessExpr().getName(), varDecls);
            if (memberType == null) {
                return null;
            }
            return Array.newInstance(memberType, 0).getClass();
        } else if (e.isNameExpr() && varDecls.containsKey(e.asNameExpr().getNameAsString())) {
            return varDecls.get(e.asNameExpr().getNameAsString());
        } else {
            return null; //gives up
        }
    }
    
    private static Class<?> classFileTypeToClass(String type) {
        final ClassLoader ic = getInternalClassLoader();
        final String typeName = internalToBinaryTypeName(type);
        Class<?> retVal = null;
        try {
            retVal = Class.forName(typeName);
        } catch (ClassNotFoundException e) {
            try {
                retVal = ic.loadClass(typeName);
            } catch (ClassNotFoundException e1) {
                retVal = null;
            }
        }
        return retVal; 
    }
    
    private static String internalToBinaryTypeName(String type) {
        if ("B".equals(type)) {
            return "byte";
        } else if ("C".equals(type)) {
            return "char";
        } else if ("D".equals(type)) {
            return "double";
        } else if ("F".equals(type)) {
            return "float";
        } else if ("I".equals(type)) {
            return "int";
        } else if ("J".equals(type)) {
            return "long";
        } else if ("S".equals(type)) {
            return "short";
        } else if ("Z".equals(type)) {
            return "boolean";
        } else if (type.startsWith("L")){
            return type.substring(1, type.length() - 1).replace('/', '.');
        } else { //array, starts with '['
            return '[' + internalToBinaryTypeName(type.substring(1));
        }
    }
    
    private static String unqualify(String className) {
    	return className.substring(className.lastIndexOf('/') + 1);    
    }
}
